# Sprint 2.2: Dynamic Memory Management Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a bump allocator for dynamic page table and device state allocation.

**Architecture:** Create a simple forward-only bump allocator with a 16MB heap at 0x41000000. Provide global heap functions and migrate page table allocation to use dynamic memory.

**Tech Stack:** Rust (no_std), no external dependencies

---

## Task 1: Create Bump Allocator

**Files:**
- Create: `src/mm/mod.rs`
- Create: `src/mm/allocator.rs`
- Modify: `src/lib.rs`
- Create: `tests/test_allocator.rs`
- Modify: `tests/mod.rs`

**Step 1: Write the failing test**

```rust
// tests/test_allocator.rs

use crate::mm::allocator::BumpAllocator;

pub fn run_allocator_test() {
    crate::uart_puts(b"\n[ALLOC] Starting allocator test...\n");

    let heap_start = 0x4100_0000u64;
    let heap_size = 0x10_0000u64; // 1MB

    let mut alloc = unsafe { BumpAllocator::new(heap_start, heap_size) };

    // Test 1: Allocate 4KB page
    let page1 = alloc.alloc_page();
    assert!(page1.is_some());
    let page1 = page1.unwrap();
    assert_eq!(page1 % 4096, 0);
    crate::uart_puts(b"[ALLOC] Page allocation OK\n");

    // Test 2: Sequential allocation
    let page2 = alloc.alloc_page();
    assert!(page2.is_some());
    assert_eq!(page2.unwrap(), page1 + 4096);
    crate::uart_puts(b"[ALLOC] Sequential allocation OK\n");

    // Test 3: Aligned allocation
    let aligned = alloc.alloc_aligned(256, 2048);
    assert!(aligned.is_some());
    assert_eq!(aligned.unwrap() % 2048, 0);
    crate::uart_puts(b"[ALLOC] Aligned allocation OK\n");

    // Test 4: Remaining space
    let remaining = alloc.remaining();
    assert!(remaining > 0);
    crate::uart_puts(b"[ALLOC] Remaining space check OK\n");

    crate::uart_puts(b"[ALLOC] All allocator tests passed!\n");
}
```

**Step 2: Run test to verify it fails**

Run: `make build`
Expected: FAIL with "unresolved import `crate::mm`"

**Step 3: Write bump allocator implementation**

```rust
// src/mm/allocator.rs

//! Simple bump allocator for hypervisor heap

pub struct BumpAllocator {
    next: u64,
    end: u64,
    allocated: u64,
}

impl BumpAllocator {
    pub const unsafe fn new(start: u64, size: u64) -> Self {
        Self {
            next: start,
            end: start + size,
            allocated: 0,
        }
    }

    pub fn alloc_page(&mut self) -> Option<u64> {
        self.alloc_aligned(4096, 4096)
    }

    pub fn alloc_aligned(&mut self, size: u64, align: u64) -> Option<u64> {
        let aligned = (self.next + align - 1) & !(align - 1);
        let new_next = aligned + size;

        if new_next > self.end {
            return None;
        }

        self.next = new_next;
        self.allocated += size;
        Some(aligned)
    }

    pub fn alloc(&mut self, size: u64) -> Option<u64> {
        self.alloc_aligned(size, 4)
    }

    pub fn remaining(&self) -> u64 {
        self.end - self.next
    }

    pub fn allocated(&self) -> u64 {
        self.allocated
    }

    pub unsafe fn reset(&mut self) {
        self.next = self.end - self.remaining() - self.allocated;
        self.allocated = 0;
    }
}
```

```rust
// src/mm/mod.rs

//! Memory management subsystem

pub mod allocator;
pub use allocator::BumpAllocator;
```

```rust
// src/lib.rs - add module

pub mod mm;
```

**Step 4: Run test to verify it passes**

Run: `make build && make run`
Expected: PASS

**Step 5: Commit**

```bash
git add src/mm/mod.rs src/mm/allocator.rs src/lib.rs tests/test_allocator.rs tests/mod.rs
git commit -m "$(cat <<'EOF'
feat(mm): add bump allocator for dynamic memory

Implement simple forward-only allocator for page tables
and long-lived hypervisor allocations.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 2: Create Global Heap Instance

**Files:**
- Create: `src/mm/heap.rs`
- Modify: `src/mm/mod.rs`
- Modify: `src/main.rs`
- Create: `tests/test_heap.rs`

**Step 1: Write the failing test**

```rust
// tests/test_heap.rs

pub fn run_heap_test() {
    crate::uart_puts(b"\n[HEAP] Testing global heap...\n");

    let page = crate::mm::heap::alloc_page();
    assert!(page.is_some());
    crate::uart_puts(b"[HEAP] Global page allocation OK\n");

    let ptr = page.unwrap() as *mut u64;
    unsafe {
        *ptr = 0xDEADBEEF;
        assert_eq!(*ptr, 0xDEADBEEF);
    }
    crate::uart_puts(b"[HEAP] Write to allocated page OK\n");

    crate::uart_puts(b"[HEAP] Global heap test passed!\n");
}
```

**Step 2: Run test to verify it fails**

Run: `make build`
Expected: FAIL

**Step 3: Implement global heap**

```rust
// src/mm/heap.rs

//! Global heap management

use super::BumpAllocator;
use core::cell::UnsafeCell;

const HEAP_START: u64 = 0x4100_0000;
const HEAP_SIZE: u64 = 0x100_0000; // 16MB

struct GlobalHeap {
    allocator: UnsafeCell<Option<BumpAllocator>>,
}

unsafe impl Sync for GlobalHeap {}

static HEAP: GlobalHeap = GlobalHeap {
    allocator: UnsafeCell::new(None),
};

pub unsafe fn init() {
    let alloc = BumpAllocator::new(HEAP_START, HEAP_SIZE);
    *HEAP.allocator.get() = Some(alloc);
}

pub fn alloc_page() -> Option<u64> {
    unsafe {
        (*HEAP.allocator.get())
            .as_mut()
            .and_then(|a| a.alloc_page())
    }
}

pub fn alloc_aligned(size: u64, align: u64) -> Option<u64> {
    unsafe {
        (*HEAP.allocator.get())
            .as_mut()
            .and_then(|a| a.alloc_aligned(size, align))
    }
}

pub fn remaining() -> u64 {
    unsafe {
        (*HEAP.allocator.get())
            .as_ref()
            .map(|a| a.remaining())
            .unwrap_or(0)
    }
}
```

```rust
// src/mm/mod.rs - add module

pub mod heap;
```

```rust
// src/main.rs - add initialization after other inits

unsafe { crate::mm::heap::init(); }
uart_puts(b"[INIT] Heap initialized\n");
```

**Step 4: Run test to verify it passes**

Run: `make build && make run`
Expected: PASS

**Step 5: Commit**

```bash
git add src/mm/heap.rs src/mm/mod.rs src/main.rs tests/test_heap.rs tests/mod.rs
git commit -m "$(cat <<'EOF'
feat(mm): add global heap singleton

Initialize 16MB heap at 0x41000000 for hypervisor
dynamic allocations.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 3: Use Dynamic Allocation for Page Tables

**Files:**
- Modify: `src/arch/aarch64/mm/mmu.rs`
- Create: `tests/test_dynamic_pagetable.rs`

**Step 1: Write the failing test**

```rust
// tests/test_dynamic_pagetable.rs

pub fn run_dynamic_pt_test() {
    crate::uart_puts(b"\n[DYN PT] Testing dynamic page table allocation...\n");

    let mut mapper = crate::arch::aarch64::mm::mmu::DynamicIdentityMapper::new();

    let result = mapper.map_region(0x1000_0000, 0x200000,
        crate::arch::aarch64::mm::mmu::MemoryAttribute::Normal);
    assert!(result.is_ok());
    crate::uart_puts(b"[DYN PT] Dynamic mapping OK\n");

    let vttbr = mapper.vttbr();
    assert!(vttbr != 0);
    crate::uart_puts(b"[DYN PT] VTTBR configured OK\n");

    crate::uart_puts(b"[DYN PT] Dynamic page table test passed!\n");
}
```

**Step 2: Run test to verify it fails**

Run: `make build`
Expected: FAIL

**Step 3: Implement dynamic page table allocation**

```rust
// src/arch/aarch64/mm/mmu.rs - add DynamicIdentityMapper

pub struct DynamicIdentityMapper {
    l1_table: u64,
    l2_tables: [u64; 4],
    l2_count: usize,
}

impl DynamicIdentityMapper {
    pub fn new() -> Self {
        let l1 = crate::mm::heap::alloc_page()
            .expect("Failed to allocate L1 table");

        unsafe {
            core::ptr::write_bytes(l1 as *mut u8, 0, 4096);
        }

        Self {
            l1_table: l1,
            l2_tables: [0; 4],
            l2_count: 0,
        }
    }

    pub fn map_region(&mut self, ipa: u64, size: u64, attr: MemoryAttribute) -> Result<(), &'static str> {
        let mut offset = 0;
        while offset < size {
            let current_ipa = ipa + offset;
            let l1_idx = (current_ipa >> 30) as usize & 0x1FF;
            let l2_table = self.get_or_create_l2(l1_idx)?;
            let l2_idx = (current_ipa >> 21) as usize & 0x1FF;
            let entry = self.make_block_entry(current_ipa, attr);

            unsafe {
                let l2_ptr = l2_table as *mut u64;
                *l2_ptr.add(l2_idx) = entry;
            }

            offset += 0x20_0000;
        }
        Ok(())
    }

    fn get_or_create_l2(&mut self, l1_idx: usize) -> Result<u64, &'static str> {
        let l1_entry = unsafe {
            let l1_ptr = self.l1_table as *const u64;
            *l1_ptr.add(l1_idx)
        };

        if l1_entry & 0x3 == 0x3 {
            return Ok(l1_entry & !0xFFF);
        }

        if self.l2_count >= 4 {
            return Err("Too many L2 tables");
        }

        let l2 = crate::mm::heap::alloc_page()
            .ok_or("Failed to allocate L2 table")?;

        unsafe {
            core::ptr::write_bytes(l2 as *mut u8, 0, 4096);
        }

        self.l2_tables[self.l2_count] = l2;
        self.l2_count += 1;

        let l1_entry = l2 | 0x3;
        unsafe {
            let l1_ptr = self.l1_table as *mut u64;
            *l1_ptr.add(l1_idx) = l1_entry;
        }

        Ok(l2)
    }

    fn make_block_entry(&self, pa: u64, attr: MemoryAttribute) -> u64 {
        let attr_bits = match attr {
            MemoryAttribute::Normal => 0x405,
            MemoryAttribute::Device => 0x409,
            MemoryAttribute::ReadOnly => 0x485,
        };
        (pa & !0x1F_FFFF) | attr_bits | 0x1
    }

    pub fn vttbr(&self) -> u64 {
        self.l1_table
    }
}
```

**Step 4: Run test to verify it passes**

Run: `make build && make run`
Expected: PASS

**Step 5: Commit**

```bash
git add src/arch/aarch64/mm/mmu.rs tests/test_dynamic_pagetable.rs tests/mod.rs
git commit -m "$(cat <<'EOF'
feat(mm): add dynamic page table allocation

Implement DynamicIdentityMapper using heap allocation
for L1 and L2 page tables instead of static arrays.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Summary

**Sprint 2.2 Tasks:**
1. Create bump allocator (allocator.rs)
2. Create global heap instance (heap.rs)
3. Use dynamic allocation for page tables (DynamicIdentityMapper)

**Estimated time: 4-6 hours**

**Dependencies:** Sprint 2.1 (optional, can run independently)

**Next:** Sprint 2.3 - Multi-vCPU Support
