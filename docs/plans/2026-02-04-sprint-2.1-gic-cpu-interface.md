# Sprint 2.1: GICv3 Virtual Interface Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement complete GICv3 virtual interrupt interface using List Registers for proper interrupt acknowledgment and EOI handling.

**Architecture:** Use GICv3 system registers (ICC_*, ICH_*) instead of MMIO. Use List Registers for hardware-assisted virtual interrupt injection. Target ARMv8.4+ features.

**Tech Stack:** Rust (no_std), ARM64, GICv3, ARMv8.4+

**References:**
- `docs/GICV3_IMPLEMENTATION.md` - Existing GICv3 implementation details
- `src/arch/aarch64/peripherals/gicv3.rs` - Existing GICv3 code

---

## Background

The project already has GICv3 support in `src/arch/aarch64/peripherals/gicv3.rs`. This sprint extends it with:
1. Complete virtual CPU interface (vGIC)
2. Proper List Register management for multiple pending interrupts
3. Full EOI handling through LR state transitions

### GICv3 vs GICv2

| Feature | GICv2 (MMIO) | GICv3 (System Regs) |
|---------|--------------|---------------------|
| Interface | Memory-mapped | System registers |
| Concurrent interrupts | 1 (HCR_EL2.VI) | 4-16 (List Registers) |
| Priority | No | Full support |
| EOI | Software | Hardware automatic |
| State management | Software | Hardware |

---

## Task 1: Extend GICv3 Virtual Interface

**Files:**
- Modify: `src/arch/aarch64/peripherals/gicv3.rs`
- Create: `tests/test_gicv3_virt.rs`
- Modify: `tests/mod.rs`

**Step 1: Write the failing test**

```rust
// tests/test_gicv3_virt.rs

use crate::arch::aarch64::peripherals::gicv3::GicV3VirtualInterface;

pub fn run_gicv3_virt_test() {
    crate::uart_puts(b"\n[GICv3 VIRT] Starting GICv3 virtual interface test...\n");

    // Test 1: Read VTR to get LR count
    let vtr = GicV3VirtualInterface::read_vtr();
    let num_lrs = ((vtr & 0x1F) + 1) as u32;
    assert!(num_lrs >= 4, "Expected at least 4 LRs");
    crate::uart_puts(b"[GICv3 VIRT] VTR read OK, LRs: ");
    // ... print num_lrs
    crate::uart_puts(b"\n");

    // Test 2: Write and read LR
    let test_lr = GicV3VirtualInterface::build_lr(27, 0xA0); // IRQ 27, priority 0xA0
    GicV3VirtualInterface::write_lr(0, test_lr);
    let read_back = GicV3VirtualInterface::read_lr(0);
    assert_eq!(read_back, test_lr);
    crate::uart_puts(b"[GICv3 VIRT] LR write/read OK\n");

    // Test 3: Clear LR
    GicV3VirtualInterface::write_lr(0, 0);
    let cleared = GicV3VirtualInterface::read_lr(0);
    assert_eq!(cleared & (0x3 << 62), 0); // State should be Invalid
    crate::uart_puts(b"[GICv3 VIRT] LR clear OK\n");

    // Test 4: Find free LR
    let free_lr = GicV3VirtualInterface::find_free_lr();
    assert!(free_lr.is_some());
    crate::uart_puts(b"[GICv3 VIRT] Find free LR OK\n");

    crate::uart_puts(b"[GICv3 VIRT] All tests passed!\n");
}
```

**Step 2: Run test to verify it fails**

Run: `make build`
Expected: FAIL - Missing methods

**Step 3: Extend GicV3VirtualInterface**

```rust
// src/arch/aarch64/peripherals/gicv3.rs - extend existing impl

impl GicV3VirtualInterface {
    /// LR state values
    pub const LR_STATE_INVALID: u64 = 0b00;
    pub const LR_STATE_PENDING: u64 = 0b01;
    pub const LR_STATE_ACTIVE: u64 = 0b10;
    pub const LR_STATE_PENDING_ACTIVE: u64 = 0b11;

    /// Build a List Register value
    ///
    /// # Arguments
    /// * `intid` - Virtual interrupt ID (0-1023)
    /// * `priority` - Interrupt priority (0-255, lower = higher priority)
    pub fn build_lr(intid: u32, priority: u8) -> u64 {
        (Self::LR_STATE_PENDING << 62)  // State = Pending
            | (1u64 << 60)               // Group1
            | ((priority as u64) << 48)  // Priority
            | (intid as u64)             // vINTID
    }

    /// Get the state of an LR
    pub fn get_lr_state(lr: u64) -> u64 {
        (lr >> 62) & 0x3
    }

    /// Get the INTID from an LR
    pub fn get_lr_intid(lr: u64) -> u32 {
        (lr & 0xFFFF_FFFF) as u32
    }

    /// Find a free (invalid state) List Register
    ///
    /// Returns the index of the first free LR, or None if all are in use.
    pub fn find_free_lr() -> Option<usize> {
        let vtr = Self::read_vtr();
        let num_lrs = ((vtr & 0x1F) + 1) as usize;

        for i in 0..num_lrs {
            let lr = Self::read_lr(i);
            if Self::get_lr_state(lr) == Self::LR_STATE_INVALID {
                return Some(i);
            }
        }
        None
    }

    /// Inject a virtual interrupt via List Register
    ///
    /// # Arguments
    /// * `intid` - Virtual interrupt ID
    /// * `priority` - Interrupt priority
    ///
    /// # Returns
    /// Ok(lr_index) on success, Err if no free LR available
    pub fn inject_interrupt(intid: u32, priority: u8) -> Result<usize, &'static str> {
        let lr_idx = Self::find_free_lr().ok_or("No free List Register")?;
        let lr_value = Self::build_lr(intid, priority);
        Self::write_lr(lr_idx, lr_value);
        Ok(lr_idx)
    }

    /// Clear an interrupt from List Registers
    ///
    /// Finds and clears all LRs with the given INTID.
    pub fn clear_interrupt(intid: u32) {
        let vtr = Self::read_vtr();
        let num_lrs = ((vtr & 0x1F) + 1) as usize;

        for i in 0..num_lrs {
            let lr = Self::read_lr(i);
            if Self::get_lr_intid(lr) == intid && Self::get_lr_state(lr) != Self::LR_STATE_INVALID {
                Self::write_lr(i, 0);
            }
        }
    }

    /// Get count of pending interrupts in LRs
    pub fn pending_count() -> usize {
        let vtr = Self::read_vtr();
        let num_lrs = ((vtr & 0x1F) + 1) as usize;
        let mut count = 0;

        for i in 0..num_lrs {
            let lr = Self::read_lr(i);
            let state = Self::get_lr_state(lr);
            if state == Self::LR_STATE_PENDING || state == Self::LR_STATE_PENDING_ACTIVE {
                count += 1;
            }
        }
        count
    }
}
```

**Step 4: Run test to verify it passes**

Run: `make build && make run`
Expected: PASS

**Step 5: Commit**

```bash
git add src/arch/aarch64/peripherals/gicv3.rs tests/test_gicv3_virt.rs tests/mod.rs
git commit -m "$(cat <<'EOF'
feat(gicv3): extend virtual interface with LR management

Add build_lr, find_free_lr, inject_interrupt, clear_interrupt
for proper GICv3 virtual interrupt injection.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 2: Integrate GICv3 with Vcpu

**Files:**
- Modify: `src/vcpu_interrupt.rs`
- Modify: `src/vcpu.rs`

**Step 1: Write the failing test**

```rust
// Add to tests/test_gicv3_virt.rs

pub fn run_gicv3_vcpu_test() {
    crate::uart_puts(b"\n[GICv3 VCPU] Testing GICv3-vCPU integration...\n");

    let mut vcpu = crate::vcpu::Vcpu::new(0);

    // Inject IRQ via vCPU
    vcpu.inject_irq(27);
    assert!(vcpu.has_pending_interrupt());
    crate::uart_puts(b"[GICv3 VCPU] Inject via vCPU OK\n");

    // Clear IRQ
    vcpu.clear_irq(27);
    assert!(!vcpu.has_pending_interrupt());
    crate::uart_puts(b"[GICv3 VCPU] Clear via vCPU OK\n");

    crate::uart_puts(b"[GICv3 VCPU] Integration test passed!\n");
}
```

**Step 2: Run test to verify it fails**

Run: `make build`
Expected: FAIL - clear_irq doesn't exist

**Step 3: Update VirtualInterruptState to use GICv3**

```rust
// src/vcpu_interrupt.rs - refactor to use GICv3

use crate::arch::aarch64::peripherals::gicv3::GicV3VirtualInterface;

/// Virtual interrupt state for a vCPU
///
/// Uses GICv3 List Registers for hardware-assisted interrupt injection.
pub struct VirtualInterruptState {
    /// Pending interrupt IDs (software tracking)
    pending: [Option<u32>; 4],
    /// Use GICv3 LRs (true) or HCR_EL2.VI fallback (false)
    use_gicv3: bool,
}

impl VirtualInterruptState {
    pub fn new() -> Self {
        // Check if GICv3 is available
        let use_gicv3 = GicV3VirtualInterface::is_available();

        Self {
            pending: [None; 4],
            use_gicv3,
        }
    }

    /// Inject a virtual IRQ
    pub fn inject_irq(&mut self, irq: u32) {
        if self.use_gicv3 {
            // Use List Register
            if let Ok(_) = GicV3VirtualInterface::inject_interrupt(irq, 0xA0) {
                // Track in software too
                for slot in &mut self.pending {
                    if slot.is_none() {
                        *slot = Some(irq);
                        break;
                    }
                }
            }
        } else {
            // Fallback to HCR_EL2.VI
            self.set_hcr_vi(true);
            self.pending[0] = Some(irq);
        }
    }

    /// Clear a virtual IRQ
    pub fn clear_irq(&mut self, irq: u32) {
        if self.use_gicv3 {
            GicV3VirtualInterface::clear_interrupt(irq);
        }

        // Clear from software tracking
        for slot in &mut self.pending {
            if *slot == Some(irq) {
                *slot = None;
            }
        }

        // If no more pending, clear HCR_EL2.VI
        if !self.has_pending_interrupt() && !self.use_gicv3 {
            self.set_hcr_vi(false);
        }
    }

    /// Check if any interrupt is pending
    pub fn has_pending_interrupt(&self) -> bool {
        if self.use_gicv3 {
            GicV3VirtualInterface::pending_count() > 0
        } else {
            self.pending.iter().any(|p| p.is_some())
        }
    }

    /// Clear all pending interrupts
    pub fn clear_all(&mut self) {
        for slot in &mut self.pending {
            if let Some(irq) = *slot {
                if self.use_gicv3 {
                    GicV3VirtualInterface::clear_interrupt(irq);
                }
                *slot = None;
            }
        }
        if !self.use_gicv3 {
            self.set_hcr_vi(false);
        }
    }

    fn set_hcr_vi(&self, enable: bool) {
        unsafe {
            let mut hcr: u64;
            core::arch::asm!("mrs {}, hcr_el2", out(reg) hcr);
            if enable {
                hcr |= 1 << 7; // VI bit
            } else {
                hcr &= !(1 << 7);
            }
            core::arch::asm!("msr hcr_el2, {}", in(reg) hcr);
        }
    }
}
```

**Step 4: Update Vcpu to expose clear_irq**

```rust
// src/vcpu.rs - add clear_irq method

impl Vcpu {
    /// Clear a pending virtual IRQ
    pub fn clear_irq(&mut self, irq: u32) {
        self.virt_irq.clear_irq(irq);
    }
}
```

**Step 5: Run test to verify it passes**

Run: `make build && make run`
Expected: PASS

**Step 6: Commit**

```bash
git add src/vcpu_interrupt.rs src/vcpu.rs
git commit -m "$(cat <<'EOF'
feat(vcpu): integrate GICv3 List Registers with vCPU

Use hardware LRs for interrupt injection instead of HCR_EL2.VI.
Add clear_irq() method. Automatic fallback to GICv2 if needed.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 3: Add GICv3 Availability Check

**Files:**
- Modify: `src/arch/aarch64/peripherals/gicv3.rs`

**Step 1: Write the failing test**

```rust
// Add to tests/test_gicv3_virt.rs

pub fn run_gicv3_detect_test() {
    crate::uart_puts(b"\n[GICv3 DETECT] Testing GICv3 detection...\n");

    use crate::arch::aarch64::peripherals::gicv3::GicV3VirtualInterface;

    let available = GicV3VirtualInterface::is_available();

    if available {
        crate::uart_puts(b"[GICv3 DETECT] GICv3 is available\n");

        // Verify we can read VTR
        let vtr = GicV3VirtualInterface::read_vtr();
        assert!(vtr != 0);
    } else {
        crate::uart_puts(b"[GICv3 DETECT] GICv3 not available, will use GICv2 fallback\n");
    }

    crate::uart_puts(b"[GICv3 DETECT] Detection test passed!\n");
}
```

**Step 2: Run test to verify it fails**

Run: `make build`
Expected: FAIL - is_available doesn't exist

**Step 3: Implement availability check**

```rust
// src/arch/aarch64/peripherals/gicv3.rs - add detection

impl GicV3VirtualInterface {
    /// Check if GICv3 system register interface is available
    ///
    /// Reads ID_AA64PFR0_EL1 to check GIC version.
    /// Returns true if GICv3 or higher is available.
    pub fn is_available() -> bool {
        let pfr0: u64;
        unsafe {
            core::arch::asm!("mrs {}, ID_AA64PFR0_EL1", out(reg) pfr0);
        }

        // Bits [27:24] = GIC version
        // 0000 = GIC not present
        // 0001 = GICv3/v4 system register interface
        let gic_version = (pfr0 >> 24) & 0xF;
        gic_version >= 1
    }

    /// Check ARMv8.4+ features for enhanced virtualization
    ///
    /// ARMv8.4 adds:
    /// - Nested virtualization
    /// - Enhanced VMID
    /// - Data gathering hint
    pub fn has_armv8_4_features() -> bool {
        let mmfr2: u64;
        unsafe {
            core::arch::asm!("mrs {}, ID_AA64MMFR2_EL1", out(reg) mmfr2);
        }

        // Bits [27:24] = NV support (nested virtualization)
        // 0001 = NV, NV2 supported (ARMv8.4)
        let nv = (mmfr2 >> 24) & 0xF;
        nv >= 1
    }
}
```

**Step 4: Run test to verify it passes**

Run: `make build && make run`
Expected: PASS

**Step 5: Commit**

```bash
git add src/arch/aarch64/peripherals/gicv3.rs
git commit -m "$(cat <<'EOF'
feat(gicv3): add runtime feature detection

Add is_available() to check GICv3 support via ID_AA64PFR0_EL1.
Add has_armv8_4_features() to check ARMv8.4+ support.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 4: Complete GICv3 Interrupt Flow Test

**Files:**
- Create: `tests/test_gicv3_flow.rs`

**Step 1: Write integration test**

```rust
// tests/test_gicv3_flow.rs

pub fn run_gicv3_flow_test() {
    crate::uart_puts(b"\n[GICv3 FLOW] Testing complete GICv3 interrupt flow...\n");

    use crate::arch::aarch64::peripherals::gicv3::GicV3VirtualInterface;

    if !GicV3VirtualInterface::is_available() {
        crate::uart_puts(b"[GICv3 FLOW] GICv3 not available, skipping\n");
        return;
    }

    // Initialize virtual interface
    GicV3VirtualInterface::init();
    crate::uart_puts(b"[GICv3 FLOW] Virtual interface initialized\n");

    // Inject 3 interrupts
    assert!(GicV3VirtualInterface::inject_interrupt(27, 0xA0).is_ok());
    assert!(GicV3VirtualInterface::inject_interrupt(30, 0xB0).is_ok());
    assert!(GicV3VirtualInterface::inject_interrupt(33, 0xC0).is_ok());
    crate::uart_puts(b"[GICv3 FLOW] Injected 3 interrupts\n");

    // Verify pending count
    let pending = GicV3VirtualInterface::pending_count();
    assert_eq!(pending, 3);
    crate::uart_puts(b"[GICv3 FLOW] Pending count = 3 OK\n");

    // Clear one interrupt
    GicV3VirtualInterface::clear_interrupt(30);
    let pending = GicV3VirtualInterface::pending_count();
    assert_eq!(pending, 2);
    crate::uart_puts(b"[GICv3 FLOW] Clear one, pending = 2 OK\n");

    // Clear all
    GicV3VirtualInterface::clear_interrupt(27);
    GicV3VirtualInterface::clear_interrupt(33);
    let pending = GicV3VirtualInterface::pending_count();
    assert_eq!(pending, 0);
    crate::uart_puts(b"[GICv3 FLOW] Clear all, pending = 0 OK\n");

    crate::uart_puts(b"[GICv3 FLOW] Complete GICv3 flow test passed!\n");
}
```

**Step 2: Run test**

Run: `make build && make run`
Expected: PASS

**Step 3: Commit**

```bash
git add tests/test_gicv3_flow.rs tests/mod.rs
git commit -m "$(cat <<'EOF'
test(gicv3): add complete interrupt flow integration test

Verify inject/clear/pending_count with multiple concurrent
interrupts using GICv3 List Registers.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Summary

**Sprint 2.1 Tasks (GICv3):**
1. Extend GICv3 virtual interface with LR management
2. Integrate GICv3 with vCPU interrupt state
3. Add GICv3 availability check (ID_AA64PFR0_EL1)
4. Complete GICv3 interrupt flow test

**Estimated time: 3-4 hours**

**Target Architecture:** ARMv8.4+, GICv3

**Key Features:**
- Hardware-assisted virtual interrupt injection via List Registers
- Support for 4-16 concurrent pending interrupts
- Automatic state management (Pending → Active → Invalid)
- Priority-based interrupt handling
- Automatic fallback to HCR_EL2.VI for GICv2

**Dependencies:** Existing GICv3 code in `src/arch/aarch64/peripherals/gicv3.rs`

**Next:** Sprint 2.2 - Dynamic Memory Management
