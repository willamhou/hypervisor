# Sprint 2.4: API Documentation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add comprehensive rustdoc documentation and developer guides.

**Architecture:** Add module-level docs, type docs with examples, and create CONTRIBUTING.md.

**Tech Stack:** Rust rustdoc, Markdown

---

## Task 1: Document Core Types

**Files:**
- Modify: `src/vcpu.rs`
- Modify: `src/vm.rs`

**Step 1: Add rustdoc to vcpu.rs**

```rust
// src/vcpu.rs - add at top

//! Virtual CPU (vCPU) abstraction
//!
//! This module provides the [`Vcpu`] type which represents a virtual processor
//! that can execute guest code. Each vCPU maintains its own register context,
//! interrupt state, and execution state.
//!
//! # Architecture
//!
//! ```text
//! ┌────────────────────────────────────┐
//! │              Vcpu                  │
//! ├────────────────────────────────────┤
//! │  VcpuContext (registers)           │
//! │  VirtualInterruptState             │
//! │  VcpuState (Ready/Running/...)     │
//! └────────────────────────────────────┘
//! ```
//!
//! # Example
//!
//! ```rust,no_run
//! use hypervisor::vcpu::Vcpu;
//!
//! let mut vcpu = Vcpu::new(0);
//! vcpu.set_entry(0x4000_0000);
//! vcpu.reset();
//!
//! match vcpu.run() {
//!     Ok(()) => println!("Guest exited normally"),
//!     Err("WFI") => println!("Guest waiting for interrupt"),
//!     Err(e) => println!("Error: {}", e),
//! }
//! ```

/// Virtual CPU state machine
///
/// Transitions:
/// - `Uninitialized` → `Ready` (after `reset()`)
/// - `Ready` → `Running` (during `run()`)
/// - `Running` → `Ready` (after guest exit)
/// - `Running` → `Stopped` (on error)
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum VcpuState { /* ... */ }

/// Virtual CPU
///
/// Represents a single virtual processor that can execute guest code.
/// Each vCPU has its own register context and can receive virtual interrupts.
///
/// # Thread Safety
///
/// A `Vcpu` is not thread-safe. Only one physical CPU should access
/// a given `Vcpu` at a time.
pub struct Vcpu { /* ... */ }

impl Vcpu {
    /// Create a new vCPU with the given ID
    ///
    /// The vCPU starts in `Uninitialized` state. Call `reset()` to
    /// prepare it for execution.
    pub fn new(id: usize) -> Self { /* ... */ }

    /// Set the guest entry point address
    ///
    /// This sets the program counter (PC) that will be used when
    /// the guest starts executing.
    pub fn set_entry(&mut self, addr: u64) { /* ... */ }

    /// Reset the vCPU to initial state
    ///
    /// Clears all registers and transitions to `Ready` state.
    pub fn reset(&mut self) { /* ... */ }

    /// Run the vCPU (enter guest mode)
    ///
    /// # Returns
    ///
    /// - `Ok(())` - Guest exited normally (e.g., via hypercall)
    /// - `Err("WFI")` - Guest executed WFI instruction
    /// - `Err(msg)` - Other error occurred
    ///
    /// # Panics
    ///
    /// Panics if the vCPU is not in `Ready` state.
    pub fn run(&mut self) -> Result<(), &'static str> { /* ... */ }

    /// Inject a virtual IRQ into the guest
    ///
    /// The interrupt will be delivered when the guest has interrupts
    /// unmasked and enters/resumes execution.
    ///
    /// # Arguments
    ///
    /// * `irq` - The interrupt number to inject (e.g., 27 for timer)
    pub fn inject_irq(&mut self, irq: u32) { /* ... */ }
}
```

**Step 2: Add rustdoc to vm.rs**

```rust
// src/vm.rs - add at top

//! Virtual Machine management
//!
//! This module provides the [`Vm`] type which represents a virtual machine
//! containing one or more vCPUs, Stage-2 memory mapping, and emulated devices.
//!
//! # Architecture
//!
//! ```text
//! ┌───────────────────────────────────────────────┐
//! │                     Vm                        │
//! ├───────────────────────────────────────────────┤
//! │  vcpus[0..MAX_VCPUS]  - Virtual processors    │
//! │  mapper              - Stage-2 page tables    │
//! │  devices             - Emulated MMIO devices  │
//! │  scheduler           - vCPU scheduler         │
//! └───────────────────────────────────────────────┘
//! ```
//!
//! # Example
//!
//! ```rust,no_run
//! use hypervisor::vm::Vm;
//!
//! let mut vm = Vm::new();
//!
//! // Create vCPUs
//! vm.create_vcpu(0).unwrap();
//! vm.create_vcpu(1).unwrap();
//!
//! // Run scheduler loop
//! while let Some(vcpu_id) = vm.schedule() {
//!     match vm.run_current() {
//!         Ok(()) => vm.mark_current_done(),
//!         Err("WFI") => vm.block_current(),
//!         Err(_) => break,
//!     }
//! }
//! ```

/// Maximum number of vCPUs per VM
pub const MAX_VCPUS: usize = 8;

/// Virtual Machine
///
/// Manages a collection of vCPUs, memory mapping, and device emulation.
pub struct Vm { /* ... */ }

impl Vm {
    /// Create a new virtual machine
    ///
    /// Initializes Stage-2 page tables and device manager.
    pub fn new() -> Self { /* ... */ }

    /// Create a new vCPU with the given ID
    ///
    /// # Arguments
    ///
    /// * `vcpu_id` - Unique identifier (0 to MAX_VCPUS-1)
    ///
    /// # Errors
    ///
    /// Returns error if ID is out of range or vCPU already exists.
    pub fn create_vcpu(&mut self, vcpu_id: usize) -> Result<&mut Vcpu, &'static str> { /* ... */ }

    /// Schedule the next vCPU to run
    ///
    /// Returns the ID of the next ready vCPU, or None if all are blocked/done.
    pub fn schedule(&mut self) -> Option<usize> { /* ... */ }

    /// Run the currently scheduled vCPU
    pub fn run_current(&mut self) -> Result<(), &'static str> { /* ... */ }
}
```

**Step 3: Run documentation build**

Run: `cargo doc --target aarch64-unknown-none --no-deps`
Expected: Documentation generated without warnings

**Step 4: Commit**

```bash
git add src/vcpu.rs src/vm.rs
git commit -m "$(cat <<'EOF'
docs(vcpu,vm): add comprehensive rustdoc documentation

Document Vcpu, VcpuState, Vm with examples, architecture diagrams,
and detailed API documentation.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 2: Document Device Framework

**Files:**
- Modify: `src/devices/mod.rs`

**Step 1: Add module-level documentation**

```rust
// src/devices/mod.rs

//! Device Emulation Framework
//!
//! This module provides the infrastructure for emulating hardware devices
//! that guests interact with via MMIO (Memory-Mapped I/O).
//!
//! # Architecture
//!
//! ```text
//! Guest Memory Access
//!        │
//!        ▼
//! ┌──────────────────┐
//! │   Data Abort     │  (Stage-2 fault on MMIO region)
//! └──────────────────┘
//!        │
//!        ▼
//! ┌──────────────────┐
//! │  DeviceManager   │  (Routes by address)
//! └──────────────────┘
//!        │
//!   ┌────┴────┬───────────┐
//!   ▼         ▼           ▼
//! ┌─────┐  ┌──────┐  ┌────────┐
//! │UART │  │ GICD │  │  GICC  │
//! └─────┘  └──────┘  └────────┘
//! ```
//!
//! # Adding a New Device
//!
//! 1. Implement the [`MmioDevice`] trait
//! 2. Add the device to [`DeviceManager`]
//! 3. Map the device region in Stage-2 page tables
//!
//! # Example
//!
//! ```rust,no_run
//! use hypervisor::devices::MmioDevice;
//!
//! struct MyDevice {
//!     base: u64,
//!     reg: u32,
//! }
//!
//! impl MmioDevice for MyDevice {
//!     fn read(&mut self, offset: u64, size: u8) -> Option<u64> {
//!         match offset {
//!             0x0 => Some(self.reg as u64),
//!             _ => None,
//!         }
//!     }
//!
//!     fn write(&mut self, offset: u64, value: u64, size: u8) -> bool {
//!         match offset {
//!             0x0 => { self.reg = value as u32; true }
//!             _ => false,
//!         }
//!     }
//!
//!     fn base_address(&self) -> u64 { self.base }
//!     fn size(&self) -> u64 { 0x1000 }
//! }
//! ```

/// Trait for MMIO-accessible devices
///
/// Implement this trait to create a new emulated device.
pub trait MmioDevice {
    /// Handle a read from the device
    ///
    /// # Arguments
    ///
    /// * `offset` - Offset from base address
    /// * `size` - Access size in bytes (1, 2, 4, or 8)
    ///
    /// # Returns
    ///
    /// The value read, or `None` if the offset is invalid
    fn read(&mut self, offset: u64, size: u8) -> Option<u64>;

    /// Handle a write to the device
    ///
    /// # Arguments
    ///
    /// * `offset` - Offset from base address
    /// * `value` - Value to write
    /// * `size` - Access size in bytes (1, 2, 4, or 8)
    ///
    /// # Returns
    ///
    /// `true` if the write was handled, `false` if offset is invalid
    fn write(&mut self, offset: u64, value: u64, size: u8) -> bool;

    /// Get the base address of this device
    fn base_address(&self) -> u64;

    /// Get the size of the device's MMIO region
    fn size(&self) -> u64;

    /// Check if an address is within this device's region
    fn contains(&self, addr: u64) -> bool {
        let base = self.base_address();
        addr >= base && addr < base + self.size()
    }
}
```

**Step 2: Run documentation build**

Run: `cargo doc --target aarch64-unknown-none --no-deps`
Expected: Documentation generated

**Step 3: Commit**

```bash
git add src/devices/mod.rs
git commit -m "$(cat <<'EOF'
docs(devices): add device framework documentation

Document MmioDevice trait and DeviceManager with architecture
diagram and example for adding new devices.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 3: Create CONTRIBUTING.md

**Files:**
- Create: `CONTRIBUTING.md`

**Step 1: Write contributing guide**

```markdown
# Contributing to ARM64 Hypervisor

## Development Setup

### Prerequisites

- Rust nightly toolchain
- QEMU with ARM64 support
- ARM64 cross-compilation toolchain

```bash
# Install Rust target
rustup target add aarch64-unknown-none

# Install QEMU (Ubuntu/Debian)
sudo apt install qemu-system-arm

# Install cross-compiler
sudo apt install gcc-aarch64-linux-gnu
```

### Building

```bash
make build   # Compile
make run     # Run in QEMU
make debug   # Run with GDB server
```

### Testing

All tests run automatically on `make run`. To add a new test:

1. Create `tests/test_<name>.rs`
2. Add module to `tests/mod.rs`
3. Call test function from `src/main.rs`

## Code Style

### Rust

- Use `cargo fmt` before committing
- Run `cargo clippy` and address warnings
- Add rustdoc for public APIs

### Assembly

- Comment every instruction or logical block
- Use consistent register conventions:
  - `x0-x7`: Arguments/return values
  - `x8-x17`: Temporary (caller-saved)
  - `x19-x28`: Callee-saved
  - `x29`: Frame pointer
  - `x30`: Link register

## Adding Features

### New Device

1. Create `src/devices/<name>/mod.rs`
2. Implement `MmioDevice` trait
3. Add to `DeviceManager`
4. Map MMIO region in Stage-2 tables
5. Add test in `tests/test_<name>.rs`

### Architecture Code

- Place in `src/arch/aarch64/`
- Hypervisor (EL2) code: `hypervisor/`
- Memory management: `mm/`
- Peripherals: `peripherals/`

## Commit Messages

Follow conventional commits:

```
feat(scope): add feature
fix(scope): fix bug
docs(scope): update documentation
refactor(scope): code changes without behavior change
test(scope): add or update tests
```

## Pull Requests

1. Create feature branch from `main`
2. Write tests for new functionality
3. Ensure all tests pass (`make run`)
4. Run linter (`make clippy`)
5. Update documentation if needed
```

**Step 2: Commit**

```bash
git add CONTRIBUTING.md
git commit -m "$(cat <<'EOF'
docs: add CONTRIBUTING.md guide

Document development setup, code style, adding features,
commit conventions, and PR process.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Summary

**Sprint 2.4 Tasks:**
1. Document core types (Vcpu, VcpuState, Vm)
2. Document device framework (MmioDevice, DeviceManager)
3. Create CONTRIBUTING.md

**Estimated time: 1-2 hours**

**Dependencies:** None (can run independently)

**Output:** Generated documentation at `target/doc/`
